\chapter{A linguagem TCL}

% Quando
% Por que

A linguagem de programação \texttt{Tcl} foi criada em 1989 por John
K. Ousterhout. Ela é interpretada e atualmente sua máquina virtual
trabalha com \textit{bytecodes}. Surgiu como uma linguagem orientada a
comandos para servir a programas interativos, fornecendo tanto uma
interface procedural quanto uma interface textual. A primeira destas é
utilizada por programas que desejam incorporar e estender a
\texttt{Tcl}, a outra permite que usuários programem diretamente com a
linguagem.

Três características básicas diferenciam a \texttt{Tcl} de muitas
outras linguagens: \begin{inparaenum}
\item orientada a comandos, \item sintaxe curta, \item tudo é
  \textit{string} UTF--8\end{inparaenum}. Um programa qualquer nesta
linguagem pode ser visto como uma sequência de chamadas de funções, onde
cada chamada é descrita pela seguinte EBNF (\textit{Extended Backus-Naur Form}):
\verb!comando {argumento}!. Cada \verb!comando! invocado pode: já
pertencer a linguagem (chamado de \textit{built-in}); ou
ser um comando criado por meio de extensão da linguagem; ou ter
sido criado com a própria \texttt{Tcl}. Os elementos que seguem um comando
são passados como argumentos para o mesmo, deixando o tratamento
semântico destes argumentos por conta do comando. Todo comando retorna uma
\textit{string} UTF-8 (\textit{8-bit Unicode Transformation Format}),
vazia ou não.

Como consequência da primeira característica, \textit{keywords} não
existem na \texttt{Tcl}. Mesmo instruções como
\verb!if! ou \verb!proc! são comandos (esta última é a responsável
pela criação de novos comandos) e podem ser redefinidas, renomeadas ou
removidas pelo usuário.

Por tratar tudo como \textit{string}, os tipos de dados inicialmente
se resumiam a um único tipo. Trabalhos realizados mais tarde
\cite{sah_tc}\cite{tcl_bytecode} alteraram esta situação, modificando
a linguagem de forma que possa
haver uma representação interna mais eficiente conforme os valores vão
sendo utilizados. Entretanto, representar tudo como \textit{string} ainda
é característico da \texttt{Tcl} pois essa forma mais eficiente
precisa disponibilizar um meio de recuperar a \textit{string}
representante desta outra forma. É importante ver que certas
operações podem não fazer sentido entre \textit{strings}, como dividir
``abacate'' por ``42''. Sendo assim, indiferente de haver uma
representação interna mais eficiente ou não, os comandos ficam responsáveis
por converter os valores, conforme a necessidade, para outros
tipos para, então, realizar com sucesso ou não sua respectiva operação.

% De acordo com \citeonline{ousterhout_89}, quatro fatores tiveram
% grande impacto no projeto desta linguagem:

% \begin{enumerate}
%   \item \textbf{A linguagem é de comandos.XXX}
%   \item \textbf{A linguagem deve ser programável}
%   \item \textbf{Deve permitir um interpretador simples e eficiente}
%     ...
%   \item \textbf{Deve permitir uma interface simples para aplicações em
%       C} ...
% \end{enumerate}

\section{Sintaxe e semântica da linguagem}

A sintaxe da \texttt{Tcl} é bastante curta se comparada a outras linguagens
de uso geral. Considerando apenas a semântica da linguagem (e
desconsiderando a semântica de implementação de cada comando), também
tem-se que ela pode ser descrita rapidamente. Para entender como os
comandos são avaliados, discute-se como eles são
formados e entendidos pelo interpretador.

%Comentários são assim considerados somente quando o caractere ``#''
%aparece no lugar de um comando.

Os comandos são separados por ``;'' ou quebra de linha, contanto que
estes elementos não estejam entre aspas duplas ou chaves (``\{'',
``\}''). Separados os comandos, ainda é necessário executá-los. Para
isso, a linguagem realiza duas etapas para cada comando. Na primeira
etapa, a \texttt{Tcl} divide o comando em elementos, cuja definição será
descrita a seguir, e realiza as substituições necessárias que serão
descritas nesta seção. Separados os elementos, a segunda etapa trata de
executar o comando. Para isto, o primeiro elemento é utilizado
para localizar o procedimento associado ao comando e possibilitar sua
execução; os demais elementos são tidos como argumentos para o
procedimento.

Para definir o que são estes elementos mencionados acima, algumas
notações adicionais (palavra simples/composta) à documentação da \texttt{Tcl}
\cite{Tcl.n-manpage} foram estabelecidas aqui. De modo geral, um
elemento pode ser formado por uma palavra simples ou por uma palavra
composta. As palavras simples são
aquelas delimitadas por espaços e não fazem uso de notação adicional.
Considerando o seguinte trecho:
\texttt{puts stderr $\pi$=3},
 que imprime a \textit{string} ``\texttt{$\pi$=3}''
em \verb!stderr!, tem-se três palavras simples. As palavras compostas
são assim chamadas pois podem conter várias palavras simples mas, além
disso, também contém notações especiais. Há três formas de se
construir uma palavra composta. Ao delimitar um conjunto de
palavras simples por aspas duplas, como em: \verb|"olá, mundo!"|,
forma-se uma palavra composta que representa um único parâmetro para
algum comando. Um outro modo envolve trocar as aspas duplas por ``\{''
e ``\}''. Essa troca apresenta efeitos na substituição, que será
tratado adiante. Finalmente, utilizando colchetes também construímos
palavras compostas.

As substituições mencionadas anteriormente são agora descritas. Elas
são divididas em duas: substituição de comandos e substituição de
variáveis. A primeira destas ocorre ao fazer uso da palavra composta
que utiliza colchetes. Para entender o que ocorre na substituição de
comandos, primeiro considere o seguinte trecho de código:
\verb!puts [expr {(1 + sqrt(5))/2}]!, que imprime como resultado
uma \textit{string} cujo conteúdo pode ser interpretado como um número
que aproxima $\varphi$.
O trecho anterior contém dois
elementos: uma palavra simples e outra composta. A palavra composta foi
delimitada por colchetes e, por isso, o interpretador \texttt{Tcl}
entende que esta palavra inicia com um comando e que os demais
elementos são parâmetros para este comando. Sendo assim, a
\texttt{Tcl} avalia esse comando e substitui a palavra composta pelo
resultado obtido. Na palavra composta há ainda outra palavra composta,
mas delimitada por chaves. Nesse caso, não ocorre nenhuma substituição
e o conteúdo entre chaves é repassado para o respectivo comando. No
exemplo anterior, o comando \verb!expr! fica responsável por tratar a
\textit{string} ``\verb!(1 + sqrt(5))/2!''. Caso houvessem outras
palavras compostas delimitadas por chaves, a linguagem \texttt{Tcl}
define uma ordem natural de avaliação da esquerda para direita em
sequência.

A substituição de variáveis ocorre nos
casos em que um elemento tem sufixo ``\$", trocando o elemento pelo
valor da variável representada. Há três formatos previstos para esta
substituição: \verb!$var!, \verb!$var(chave)! e
\verb!${var}!. No primeiro caso, \verb!var! descreve o nome de uma
variável escalar. No segundo, \verb!var! é aceito como um \textit{array}
e \verb!chave! é uma \textit{string}, que pode ser formada
por uma palavra composta, que, ao ser avaliada, dá um nome para um
elemento deste \textit{array}. O último caso também se aplica a
variáveis escalares, mas aceita caracteres que desconfigurariam a
situação de palavra simples do primeiro caso. Por exemplo, poderíamos
ter o seguinte código: \verb!set {T C L} linguagem!, que, por um
motivo qualquer, define uma variável chamada \verb!T C L! com o valor
\verb!linguagem!. Para imprimir seu conteúdo é necessário, portanto,
utilizar a terceira forma: \verb!puts ${T C L}!.

% * Escape
Uma outra construção sintática existente é a barra invertida. Sua
função é possibilitar a inserção dos caracteres que podem ser
considerados especiais dependendo do contexto (\verb!"!, \verb!$!,
\verb!{!, \verb![!, \verb!\!) e também de outros não imprimíveis.

% * Expansão de argumentos

Com a distribuição da versão 8.5 da \texttt{Tcl}, uma nova
regra precisou ser criada e esse parágrafo dedica-se a ela. A razão
para isto foi a introdução de um recurso denominado expansão de
argumentos. Existe um
conflito parcial com essa regra e o que foi apresentado anteriormente,
então é necessário considerar algumas exceções que ocorrem por meio da
sintaxe para expansão de argumentos. Ao encontrar um elemento com
prefixo ``\verb!{*}!'' com sufixo que não seja caractere em
branco, a expansão de argumentos ocorre. O sufixo é avaliado e
substituído seguindo as regras já mencionadas, em seguida outra
avaliação ocorre. Como resultado pode-se ter diversos elementos. Para
entender esta situação, apresenta-se mais um exemplo:
\begin{verbatim}
set x {puts abacate}
{*}$x
\end{verbatim}
Primeiramente é definido a variável \verb!x! com conteúdo
\verb!puts abacate!. Na linha seguinte é feito uma expansão de argumentos, onde
primeiramente \verb!$x! é avaliada e substituída pelo conteúdo da
variável \verb!x!. Em seguida este mesmo conteúdo é avaliado, causando
a execução do comando \verb!puts! com argumento \verb!abacate!.

% * Comentarios

Finalmente, comentários. A \texttt{Tcl} trabalha com comentários que
se estendem até o final da linha corrente e utiliza o caractere ``\#''
para essa tarefa. Deve-se tomar cuidado ao criar um comentário, o
mesmo só é assim considerado se aparecer no ponto onde o nome de um
comando é esperado. Considere o seguinte trecho de código:
\begin{alltt}
\# Valor aproximado para \(\pi\)
set pi [expr {acos(-1)}]
\end{alltt}
Nesse caso o comentário está correto. Entretanto, se tentarmos colocar
o comentário logo em seguida do comando \verb!set!, na mesma linha, um erro
ocorreria. A linguagem entenderia que \verb!#!, \verb!Valor!, e os
demais elementos devem ser passados para o comando \verb!set! que
aceita no máximo três argumentos. Há pelo menos mais uma forma de
causar um comportamento talvez não esperado: \verb!puts [# oi]!, agora
o comentário ocorreu num lugar permitido mas, com isso, o colchete que
terminaria o comando foi descartado.

%% Tirei e descrevi tudo a cima.
%\section{Características}
%\label{sec:tcl_caracteristicas}

%\begin{itemize}
%\item exemplos de código destacando as características principais
%\end{itemize}


\section{Avaliação de comandos}

** Só se der tempo
* Falar daquela parte do Tcl\_ObjProc ou alguma coisa assim, talvez
colar do que já tem escrito.
